import org.jeom._
import scala.collection.JavaConversions._
import scala.collection.JavaConverters._

import com.vividsolutions.jts.geom.{GeometryCollection, GeometryFactory, Polygon, Geometry, Coordinate, LineString}
import com.vividsolutions.jts.index.strtree.SIRtree
import com.vividsolutions.jts.operation.polygonize.Polygonizer


val ans = PolygonExtractor.extractZCTAs()

val geometryFactory = new GeometryFactory()

import GeometryUtils.IterablePolygon

val tolerance = math.pow(2, -11)
val polygon = geometryFactory.createPolygon(ans(0).multipolygon.getBoundary.getCoordinates)
val orthPolygon = OrthogonalPolygonBuilder.build(polygon, tolerance, 5, 3)
val poly = OrthogonalPolygonBuilder.build(polygon, math.pow(2, -11), 8, 6)



import org.scalameter._
val tolerance = scala.math.pow(2, -11)
val time = config(
  Key.exec.benchRuns -> 100,
  Key.verbose -> true
) withWarmer {
  new Warmer.Default
} withMeasurer {
  new Measurer.IgnoringGC
} measure {
  OrthogonalPolygonBuilder.build(polygon)
}

println(s"Total time: $time")


def buildIntervalTree(corners: List[CornerPoint], isVertical: Boolean): SIRtree = {

  val tree: SIRtree = new SIRtree()
  val edges: Iterator[List[CornerPoint]] = corners.grouped(2)

  if (isVertical) 
    edges foreach { e => tree.insert(e.head.y, e.last.y, e) }
  else
    edges foreach { e => tree.insert(e.head.x, e.last.x, e) }

  tree
}

def extendCorner(corner: Corner, edgeTree: SIRtree): List[CornerPoint] = {
  tree
    .query(corner.extensionCoord)
    .toList.asInstanceOf[List[List[CornerPoint]]]
    .filter(c => corner.extensionOrder(c.head.point.y))
    .minBy(_.head.point.y)  
}

// val poly = OrthogonalPolygonBuilder.build(polygon, math.pow(2, -11), 8, 6)
// GeometryUtils.plotly(poly, Some(polygon), "fine tune improved method")


val corners = OrthogonalPolygonPartitioner.extractCorners(orthPolygon)
val startsVertically: Boolean = corners.head.angle.abs != 90

val hc: List[Corner] = if (startsVertically) corners.tail else corners.init
val vc: List[Corner] = if (startsVertically) corners.init else corners.tail
val tree = buildIntervalTree(hc, false)

val corner = corners.filter(c => c.isConvex && c.extendsVertically && c.point.x == -66.755807).head
val edge = extendCorner(corner, tree)

val line1 = geometryFactory.createLineString(
  Array(new Coordinate(edge.head.point.x, edge.head.point.y),
        new Coordinate(corner.point.x, edge.head.point.y)))
val line2 = geometryFactory.createLineString(
  Array(new Coordinate(corner.point.x, edge.head.point.y),
        new Coordinate(edge.last.point.x, edge.last.point.y)))
val line3 = geometryFactory.createLineString(
  Array(new Coordinate(corner.point.x, corner.point.y),
        new Coordinate(corner.point.x, edge.head.point.y)))

val badLine = geometryFactory.createLineString(
  Array(new Coordinate(edge.head.point.x, edge.head.point.y),
        new Coordinate(edge.last.point.x, edge.last.point.y)))


val lines = line1 :: line2 :: line3 :: { 
  orthPolygon.sliding(2, 1).map { points =>
    GeometryUtils
      .geometryFactory
      .createLineString(Array(points.head, points.last))
      .asInstanceOf[LineString]
  }.filter(!_.equals(badLine)).toList
}


val polygonizer = new Polygonizer(false)
polygonizer.add(lines.asJavaCollection)
polygonizer.add(lines.reverse.asJavaCollection)
// for (geo <- lines.map(_.asInstanceOf[Geometry])) {
  
val ans = polygonizer.getPolygons.toList.asInstanceOf[List[Polygon]]



val newP = polygonizer.getPolygons().toList.head.asInstanceOf[Polygon]

GeometryUtils.plotly(ans.head, Some(ans.last), "polygonizer split")



val ans = OrthogonalPolygonPartitioner.partition(orthPolygon)

import co.theasi.plotly._

def linePlotter(plt: CartesianPlot, line: ExtendedCorner): CartesianPlot = {
  val coords = Array(line.source, line.dest)
  plt.withScatter(coords.map(_.x), coords.map(_.y),
    ScatterOptions()
      .mode(ScatterMode.Marker, ScatterMode.Line)
      .marker(MarkerOptions().color(152, 0, 0, 0.8).lineColor(30, 0, 0))
  )
}

def diagPlotter(plt: CartesianPlot, line: Rectangle): CartesianPlot = {
  val coords = Array(line.upperLeft, line.lowerRight)
  plt.withScatter(coords.map(_.x), coords.map(_.y),
    ScatterOptions()
      .mode(ScatterMode.Marker, ScatterMode.Line)
      .marker(MarkerOptions().color(0, 152, 0, 0.8).lineColor(0, 30, 0))
  )
}

def plotly(
    polygon: Polygon,
    innerLines: List[ExtendedCorner],
    diagLines: List[Rectangle],
    plotName: String = "scatter-mode"): Unit = {
  import co.theasi.plotly._

  val xs0: Array[Double] = polygon.toArray.map(_.x)
  val ys0: Array[Double] = polygon.toArray.map(_.y)

  val p1 = Plot()
    .withScatter(xs0, ys0,
      ScatterOptions()
        .mode(ScatterMode.Marker, ScatterMode.Line)
        .name("Orthogonal Polygon"))

  val p2 = innerLines.foldLeft(p1)(linePlotter)
  val plot = diagLines.foldLeft(p2)(diagPlotter)
  draw(plot, plotName, writer.FileOptions(overwrite=true))
}

plotly(orthPolygon, lines, ans, "partitions finalized!")
