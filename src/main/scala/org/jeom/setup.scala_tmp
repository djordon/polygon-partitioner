import org.jeom._
import scala.collection.JavaConversions._
import scala.collection.JavaConverters._

import com.vividsolutions.jts.triangulate.DelaunayTriangulationBuilder
import com.vividsolutions.jts.simplify.DouglasPeuckerSimplifier
import com.vividsolutions.jts.geom.{GeometryCollection, GeometryFactory, Polygon, Geometry, Envelope, Coordinate, LineSegment, LineString}
import com.vividsolutions.jts.operation.union.CascadedPolygonUnion
import com.vividsolutions.jts.dissolver.LineDissolver
import com.vividsolutions.jts.index.strtree.{STRtree, SIRtree}
import com.vividsolutions.jts.algorithm.Angle

val ans = PolygonExtractor.extractZCTAs()

val geometryFactory = new GeometryFactory()

import GeometryUtils.IterablePolygon

val tolerance = math.pow(2, -11)
val polygon = geometryFactory.createPolygon(ans(0).multipolygon.getBoundary.getCoordinates)
val orthPolygon = OrthogonalPolygonBuilder.build(polygon, tolerance, 5, 3)
val orthPolygon2 = OrthogonalPolygonBuilder2.build(orthPolygon)

val simplified = DouglasPeuckerSimplifier.simplify(polygon, scala.math.pow(2, -12))
val simplePoly = geometryFactory.createPolygon(simplified.getCoordinates)

val tmp = OthogonalPolygonBuilder.reduceColinearity(orthPolygon)

GeometryUtils.plotly(tmp, Some(simplePoly), "triangulation method")


GeometryUtils.plotly(orthPolygon2, Some(polygon), "simplified 3")


import GeometryUtils.IterablePolygon

val verticalEdgeTree = new STRtree()
val horizontalEdgeTree = new STRtree()

implicit def coords2envelope(coords: List[Coordinate]): Envelope =
  new Envelope(coords.head, coords.last)


tmp.grouped(2).map(_.toList).filter(_.length > 1).foreach { 
  pair =>
    val env = new Envelope(pair)

    if (pair.head.x == pair.last.x)
      verticalEdgeTree.insert(env, pair.head)
    else 
      horizontalEdgeTree.insert(env, pair.head)
}






val MAX_ORDINATE: Double = (1 + polygon
    .getEnvelope.asInstanceOf[Polygon]
    .toList
    .flatMap(c => List(c.x, c.y))
    .map(math.abs)
    .max)

def getMaxOrdinate(polygon: Polygon): Double = {
  1.0 + polygon
    .getEnvelope.asInstanceOf[Polygon]
    .toList
    .flatMap(c => List(c.x, c.y))
    .map(math.abs)
    .max
}


val boundary = polygon.getBoundary

val tol = scala.math.pow(2, -13)




ans.map(_.map(_.intersection(polygon.getBoundary).getDimension))


tree.query(env)




import org.scalameter._
val tolerance = scala.math.pow(2, -11)
val time = config(
  Key.exec.benchRuns -> 100,
  Key.verbose -> true
) withWarmer {
  new Warmer.Default
} withMeasurer {
  new Measurer.IgnoringGC
} measure {
  OrthogonalPolygonBuilder.build(polygon)
}

println(s"Total time: $time")


val poly1 = OrthogonalPolygonBuilder.build(polygon)
val poly = OrthogonalPolygonBuilder.build(polygon, math.pow(2, -11), 8, 6)
GeometryUtils.plotly(poly, Some(polygon), "fine tune improved method")

def getMaxOrdinate(polygon: Polygon): Double = {
  1.0 + polygon
    .getEnvelope.asInstanceOf[Polygon]
    .toList
    .flatMap(c => List(c.x, c.y))
    .map(math.abs)
    .max
}
val sup = getMaxOrdinate(poly)
val corners = Whatever.getCorners(poly).filter(_.isConvex).toList

val edge = corners.head.extend(sup).intersection(poly)
val p = edge.getCoordinates()(1)

val segment = poly.filter(_.x == p.x).toList

val lines = edge.asInstanceOf[LineString] :: { 
  for (l <- segment)
    yield GeometryUtils
      .geometryFactory
      .createLineString(Array(p, l))
      .asInstanceOf[LineString]
} ::: { poly.sliding(2, 1).map { points =>
  GeometryUtils
    .geometryFactory
    .createLineString(Array(points.head, points.last))
    .asInstanceOf[LineString]
  }.toList
}
//::: edge.reverse.asInstanceOf[LineString] :: Nil

import com.vividsolutions.jts.operation.polygonize.Polygonizer

val polygonizer = new Polygonizer(false)
polygonizer.add(lines.asJavaCollection)
polygonizer.add(lines.reverse.asJavaCollection)
// for (geo <- lines.map(_.asInstanceOf[Geometry])) {
  
// }


val newP = polygonizer.getPolygons().toList.head.asInstanceOf[Polygon]

GeometryUtils.plotly(newP, Some(polygon), "polygonizer")


val horizontalEdgeTree = new SIRtree()
poly.tail.grouped(2).foreach { points =>
  val edge = points.toList
  horizontalEdgeTree.insert(edge.head.x, edge.last.x, edge.head.y)
}


def extend(z: Double, corner: Corner): LineString = {
  val p0: Coordinate = corner.angle match {
    case 0 => new Coordinate(z, corner.coord.y)
    case 90 => new Coordinate(corner.coord.x, z)
    case 180 => new Coordinate(z, corner.coord.y)
    case -90 => new Coordinate(corner.coord.x, z)
    case _ => new Coordinate()
  }

  GeometryUtils.geometryFactory.createLineString(Array(corner.coord, p0))
}

def extendCorner(corner: Corner, edgeTree: SIRtree): LineString = {
  val candidates: Iterable[Double] = edgeTree
    .query(corner.renameMe)
    .toList.asInstanceOf[List[Double]]
    .filter(corner.predicate(_))

  val z: Double = if (corner.angle == 90 || corner.angle == 0) candidates.min else candidates.max
  extend(z, corner)
}

val corners = Whatever.getCorners(poly).filter(_.isConvex).toList

val extendedLines = (corners
  .filter(x => x.angle == 90 || x.angle == -90)
  .map { extendCorner(_, horizontalEdgeTree) } )

val verticalEdgeTree = new SIRtree()
((poly.init ++ extendedLines.map(_.getCoordinates).flatten)
  .grouped(2)
  .foreach { points =>
    val edge = points.toList
    verticalEdgeTree.insert(edge.head.y, edge.last.y, edge.head.x)
  })

val extendedLines2 = (corners
  .filter(x => x.angle == 0 || x.angle == 180)
  .map { extendCorner(_, verticalEdgeTree) } )


import com.vividsolutions.jts.operation.polygonize.Polygonizer

val lines = extendedLines ++ extendedLines2 ++ poly.sliding(2, 1).map { points =>
  GeometryUtils
    .geometryFactory
    .createLineString(Array(points.head, points.last))
    .asInstanceOf[LineString]
  }.toList

val polygonizer = new Polygonizer()
polygonizer.add(lines.asJavaCollection)
polygonizer.add(lines.flatMap(_.getCoordinates).map {
  GeometryUtils
    .geometryFactory
    .createPoint(_) 
}.asJavaCollection)

def linePlotter(plt: CartesianPlot, line: LineString): CartesianPlot = {
  val coords = line.getCoordinates.toArray
  plt.withScatter(coords.map(_.x), coords.map(_.y),
    ScatterOptions()
      .mode(ScatterMode.Marker, ScatterMode.Line)
      .marker(MarkerOptions().color(152, 0, 0, 0.8).lineColor(30, 0, 0))
  )
}

def plotly(
    polygon: Polygon,
    innerLines: List[LineString],
    plotName: String = "scatter-mode"): Unit = {
  import co.theasi.plotly._

  val xs0: Array[Double] = polygon.toArray.map(_.x)
  val ys0: Array[Double] = polygon.toArray.map(_.y)

  val p = Plot()
    .withScatter(xs0, ys0,
      ScatterOptions()
        .mode(ScatterMode.Marker, ScatterMode.Line)
        .name("Orthogonal Polygon"))

  val plot = innerLines.foldLeft(p)(linePlotter)
  draw(plot, plotName, writer.FileOptions(overwrite=true))
}

plotly(poly, extendedLines ++ extendedLines2, "partitions?")
