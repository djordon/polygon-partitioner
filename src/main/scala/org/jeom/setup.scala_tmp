import org.jeom._
import scala.collection.JavaConversions._
import scala.collection.JavaConverters._

import com.vividsolutions.jts.triangulate.DelaunayTriangulationBuilder
import com.vividsolutions.jts.simplify.DouglasPeuckerSimplifier
import com.vividsolutions.jts.geom.{GeometryCollection, GeometryFactory, Polygon, Geometry, Envelope, Coordinate, LineSegment, LineString}
import com.vividsolutions.jts.operation.union.CascadedPolygonUnion
import com.vividsolutions.jts.dissolver.LineDissolver
import com.vividsolutions.jts.index.strtree.STRtree
import com.vividsolutions.jts.algorithm.Angle

val ans = PolygonExtractor.extractZCTAs()

val geoFactory = new GeometryFactory()

import GeometryUtils.IterablePolygon

val polygon = geoFactory.createPolygon(ans(0).multipolygon.getBoundary.getCoordinates)
val orthPolygon = OthogonalPolygonBuilder.build(polygon)


val simplified = DouglasPeuckerSimplifier.simplify(polygon, scala.math.pow(2, -12))
val simplePoly = geoFactory.createPolygon(simplified.getCoordinates)

val tmp = OthogonalPolygonBuilder.reduceColinearity(orthPolygon)

GeometryUtils.plotly(tmp, Some(simplePoly), "triangulation method")


import GeometryUtils.IterablePolygon

val verticalEdgeTree = new STRtree()
val horizontalEdgeTree = new STRtree()

implicit def coords2envelope(coords: List[Coordinate]): Envelope =
  new Envelope(coords.head, coords.last)


tmp.grouped(2).map(_.toList).filter(_.length > 1).foreach { 
  pair =>
    val env = new Envelope(pair)

    if (pair.head.x == pair.last.x)
      verticalEdgeTree.insert(env, pair.head)
    else 
      horizontalEdgeTree.insert(env, pair.head)
}

case class Corner(coordinate: Coordinate, isConvex: Boolean, direction: Int)

object Corner {
  def isConvexCorner(corner: List[Coordinate]): Boolean =
    Angle.angleBetweenOriented(corner(0), corner(1), corner(2)) < 0

  def edgeDirection(vec: List[Coordinate]): Int = 
    (Angle.angle(vec.head, vec.last) * 360 / Angle.PI_TIMES_2).toInt

  def apply(coords: List[Coordinate]) =
    new Corner(coords(1), isConvexCorner(coords), edgeDirection(coords.take(2)))
}


def getCorners(polygon: Polygon): Iterator[Corner] = {
  val boundary: List[Coordinate] = polygon.toList.tail
  val extended: List[Coordinate] = Stream
    .continually(boundary)
    .flatten
    .take(boundary.length + 2)
    .toList

  extended.sliding(3, 1).map(Corner.apply)
}

getCorners(tmp).map(Corner.apply)




val MAX_ORDINATE: Double = (polygon
  .getEnvelope.asInstanceOf[Polygon]
  .toList
  .flatMap(c => List(c.x, c.y))
  .map(math.abs)
  .max)

val boundary = polygon.getBoundary

val ans = polygon.toList.map { c =>
  val c_n = new Coordinate(c.x, MAX_ORDINATE)
  val c_e = new Coordinate(MAX_ORDINATE, c.y)
  val c_s = new Coordinate(c.x, -MAX_ORDINATE)
  val c_w = new Coordinate(-MAX_ORDINATE, c.y)
  val lines = for (p <- List(c_n, c_e, c_s, c_w))
    yield geoFactory.createLineString(Array(p, c))
  lines.filter(_.intersection(boundary).getNumPoints == 1)
}.filter(_.length == 2)

val tmp = ans.map { lines =>
  geoFactory
    .createLineString(lines.flatMap(_.getCoordinates).toArray)
    .getEnvelope
}.filter(_.getDimension == 2).map(_.asInstanceOf[Polygon])

val cover = (polygon
  .getEnvelope
  .difference(CascadedPolygonUnion.union(tmp.asJavaCollection))
  .asInstanceOf[Polygon])


GeometryUtils.plotly(cover, Some(polygon), "new method")

ans.map(_.map(_.intersection(polygon.getBoundary).getDimension))

new Envelope(c_n, c), new Envelope(c_e, c), new Envelope(c_s, c), new Envelope(c_w, c)
val a = tmp.sliding(2, 1).map(_.toList).filter(_.length > 1).map { x =>
  Angle.angle(x(0), x(1))
}.toList

val c1 = tmp.toList(20)
val c2 = new Coordinate(Double.NegativeInfinity, c1.y)
val env = new Envelope(c2, c1)

tree.query(env)


// for (i <- 0 until 20)
//   yield Angle.interiorAngle(y(i), y(i+1), y(i+2))
// 
// 
// 
// val z = Stream.continually(boundary).flatten.take(boundary.length + 2).toList.sliding(3, 1).map(_.).toList
// 
// val test1 = for (y <- z)
//   yield Angle.angleBetweenOriented(y(0), y(1), y(2)) < 0
// 
// val test2 = for (y <- z)
//   yield isConvex1(y)
// 
// def isConvex1(triplet: List[Coordinate]): Boolean = {
//   val x1 = triplet.head.x == triplet.tail.head.x
//   val x2 = triplet.head.y > triplet.tail.head.y
//   val x3 = triplet.tail.head.x > triplet.last.x
//   val x4 = triplet.tail.head.x < triplet.last.x
//   val x5 = triplet.tail.head.y > triplet.last.y
//   val x6 = triplet.head.x < triplet.tail.head.x
// 
//   if (x1) {
//     if (x2) {
//       if (x4) true else false
//     } else {
//       if (x3) true else false
//     }
//   } else {
//     if (x6) {
//       if (!x5) true else false
//     } else {
//       if (x5) true else false
//     }
//   }
// }
