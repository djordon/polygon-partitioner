import org.jeom._

import com.vividsolutions.jts.geom.{Polygon, GeometryFactory, Coordinate}
import com.vividsolutions.jts.shape.random.RandomPointsBuilder

import scala.collection.JavaConverters._

import GeometryUtils.IterablePolygon

val wktReader = new WKTReader()

val geometryFactory = new GeometryFactory()
val randomGeometryFactory = new RandomPointsBuilder()

def generatePolygon(numPoints: Int = 50): Polygon = {
  randomGeometryFactory.setNumPoints(numPoints)

  randomGeometryFactory
    .getGeometry
    .convexHull
    .norm()
    .asInstanceOf[Polygon]
}

def printThis(p: List[Coordinate]): Unit = {
  for (c <- p) {println(s"$c")}
}

for (i <- 0 until 100) {
  val original: Polygon = generatePolygon()
  val poly1: Polygon = OrthogonalPolygonBuilder.cover(original)
  println(i)
  try {
    val recs2: List[Rectangle] = OrthogonalPolygonPartitioner.partition(poly1)
  } catch {
    case e: Exception => { 
      printThis(poly1.toList)
      println(s"Failed $i")
      // e.printStackTrace
      // GeometryUtils.plotly(poly2, Some(original), s"try $i")
    }
  }
}



import org.jeom._

import scala.collection.immutable.TreeSet
import scala.collection.JavaConversions._
import scala.collection.JavaConverters._
import scala.collection.Searching.{search, Found, InsertionPoint, SearchResult}

import com.vividsolutions.jts.geom.{GeometryCollection, GeometryFactory, Polygon, Geometry, Coordinate, LineString}
import com.vividsolutions.jts.index.strtree.SIRtree
import com.vividsolutions.jts.operation.polygonize.Polygonizer


val ans = PolygonExtractor.extractZCTAs()

val geometryFactory = new GeometryFactory()

import GeometryUtils.IterablePolygon

val tolerance = math.pow(2, -11)
val polygon = geometryFactory.createPolygon(ans(0).multipolygon.getBoundary.getCoordinates)
val orthPolygon = OrthogonalPolygonBuilder.approximate(polygon, tolerance, 5, 3)
// val poly = OrthogonalPolygonBuilder.build(polygon, math.pow(2, -11), 8, 6)

val ans = OrthogonalPolygonPartitioner.partition(orthPolygon)

// val corners = OrthogonalPolygonPartitioner.extractCorners(orthPolygon)
val startsVertically: Boolean = corners.head.angle.abs != 90

val hc: List[Corner] = if (startsVertically) corners.tail else corners.init
val vc: List[Corner] = if (startsVertically) corners.init else corners.tail

val treeSet = TreeSet[Double]()
val empty: List[ExtendedCorner] = Nil

val (_, ves) = hc.sorted(CornerOrderingX).foldLeft((treeSet, empty)) {
    (tuple: Tuple2[TreeSet[Double], List[ExtendedCorner]], cn: Corner) =>

  val (tm, ecs) = tuple
  cn match {
    case Corner(Point(x, y), true, 90) if (tm.contains(y)) =>
      (tm - y, ExtendedCorner(cn.point, Point(x, (tm - y).from(y).firstKey), cn.angle) :: ecs)

    case Corner(Point(x, y), true, 90) if (!tm.contains(y)) =>
      (tm + y, ExtendedCorner(cn.point, Point(x, tm.from(y).firstKey), cn.angle) :: ecs)

    case Corner(Point(x, y), true, -90) if (tm.contains(y)) =>
      (tm - y, ExtendedCorner(cn.point, Point(x, (tm - y).to(y).lastKey), cn.angle) :: ecs)

    case Corner(Point(x, y), true, -90) if (!tm.contains(y)) =>
      (tm + y, ExtendedCorner(cn.point, Point(x, tm.to(y).lastKey), cn.angle) :: ecs)

    case Corner(Point(_, y), _, _) if (tm.contains(y)) => (tm - y, ecs)

    case Corner(Point(_, y), _, _) if (!tm.contains(y)) => (tm + y, ecs)
  }
}

val (_, ves2) = hc.sorted(CornerOrderingX).foldLeft((treeSet, empty)) {
    (tuple: Tuple2[TreeSet[Double], List[ExtendedCorner]], cn: Corner) =>

  val (tm, ecs) = tuple
  if (tm.contains(cn.y))
    cn match {
      case Corner(Point(x, y), true, 90) =>
        (tm - y, cn.extendCorner(tm - y) :: ecs)
        // (tm - y, ExtendedCorner(cn.point, Point(x, (tm - y).from(y).firstKey), cn.angle) :: ecs)

      case Corner(Point(x, y), true, -90) =>
        (tm - y, cn.extendCorner(tm - y) :: ecs)
        // (tm - y, ExtendedCorner(cn.point, Point(x, (tm - y).to(y).lastKey), cn.angle) :: ecs)

      case Corner(Point(_, y), _, _) if (tm.contains(y)) => (tm - y, ecs)
    }
  else
    cn match {
      case Corner(Point(x, y), true, 90) =>
        (tm + y, cn.extendCorner(tm - y) :: ecs)
        // (tm + y, ExtendedCorner(cn.point, Point(x, tm.from(y).firstKey), cn.angle) :: ecs)

      case Corner(Point(x, y), true, -90) =>
        (tm + y, cn.extendCorner(tm - y) :: ecs)
        // (tm + y, ExtendedCorner(cn.point, Point(x, tm.to(y).lastKey), cn.angle) :: ecs)

      case Corner(Point(_, y), _, _) => (tm + y, ecs)
    }
}


ves.toSet == vEdges.toSet
val vCorners: List[Corner] = ves.flatMap(_.toListCorner)


val (_, hes) = (vc ++ vCorners).sorted(YOrdering1).foldLeft((treeSet, empty)) {
    (tuple: Tuple2[TreeSet[Double], List[ExtendedCorner]], cn: Corner) =>

  val (tm, ecs) = tuple
  if (tm.contains(cn.x))
    cn match {
      case Corner(Point(x, y), true, 0) =>
        (tm - x, ExtendedCorner(cn, Point((tm - x).from(x).firstKey, y)) :: ecs)

      case Corner(Point(x, y), true, 180) =>
        (tm - x, ExtendedCorner(cn, Point((tm - x).to(x).lastKey, y)) :: ecs)

      case Corner(Point(x, _), _, _) => (tm - x, ecs)
    }
  else
    cn match {
      case Corner(Point(x, y), true, 0) =>
        (tm + x, ExtendedCorner(cn, Point(tm.from(x).firstKey, y)) :: ecs)

      case Corner(Point(x, y), true, 180) =>
        (tm + x, ExtendedCorner(cn, Point(tm.to(x).lastKey, y)) :: ecs)

      case Corner(Point(x, _), _, _) => (tm + x, ecs)
    }
}



val vEdges: List[ExtendedCorner] = OrthogonalPolygonPartitioner.extendCorners(corners.tail, hc, true)
val vCorners: List[Corner] = vEdges.flatMap(_.toListCorner)
val hEdges: List[ExtendedCorner] = OrthogonalPolygonPartitioner.extendCorners(corners.tail, vCorners ++ vc, false)

val t = scala.collection.immutable.TreeMap[Double, Double](1.2 -> 9.0, 2.0 -> 3.9 , -2.3 -> 4.5, 9.9 -> 17.2)

t match {
  case _: IndexedSeqLike[Double] => println("hope")
  case _ => println("damn")
}

import org.scalameter._
val tolerance = scala.math.pow(2, -11)
val time = config(
  Key.exec.benchRuns -> 100,
  Key.verbose -> true
) withWarmer {
  new Warmer.Default
} withMeasurer {
  new Measurer.IgnoringGC
} measure {
  OrthogonalPolygonBuilder.build(polygon)
}

println(s"Total time: $time")


def buildIntervalTree(corners: List[CornerPoint], isVertical: Boolean): SIRtree = {

  val tree: SIRtree = new SIRtree()
  val edges: Iterator[List[CornerPoint]] = corners.grouped(2)

  if (isVertical) 
    edges foreach { e => tree.insert(e.head.y, e.last.y, e) }
  else
    edges foreach { e => tree.insert(e.head.x, e.last.x, e) }

  tree
}

def extendCorner(corner: Corner, edgeTree: SIRtree): List[CornerPoint] = {
  tree
    .query(corner.extensionCoord)
    .toList.asInstanceOf[List[List[CornerPoint]]]
    .filter(c => corner.extensionOrder(c.head.point.y))
    .minBy(_.head.point.y)  
}

// val poly = OrthogonalPolygonBuilder.build(polygon, math.pow(2, -11), 8, 6)
// GeometryUtils.plotly(poly, Some(polygon), "fine tune improved method")


val corners = OrthogonalPolygonPartitioner.extractCorners(orthPolygon)
val startsVertically: Boolean = corners.head.angle.abs != 90

val hc: List[Corner] = if (startsVertically) corners.tail else corners.init
val vc: List[Corner] = if (startsVertically) corners.init else corners.tail
val tree = buildIntervalTree(hc, false)

val corner = corners.filter(c => c.isConcave && c.extendsVertically && c.point.x == -66.755807).head
val edge = extendCorner(corner, tree)

val line1 = geometryFactory.createLineString(
  Array(new Coordinate(edge.head.point.x, edge.head.point.y),
        new Coordinate(corner.point.x, edge.head.point.y)))
val line2 = geometryFactory.createLineString(
  Array(new Coordinate(corner.point.x, edge.head.point.y),
        new Coordinate(edge.last.point.x, edge.last.point.y)))
val line3 = geometryFactory.createLineString(
  Array(new Coordinate(corner.point.x, corner.point.y),
        new Coordinate(corner.point.x, edge.head.point.y)))

val badLine = geometryFactory.createLineString(
  Array(new Coordinate(edge.head.point.x, edge.head.point.y),
        new Coordinate(edge.last.point.x, edge.last.point.y)))


val lines = line1 :: line2 :: line3 :: { 
  orthPolygon.sliding(2, 1).map { points =>
    GeometryUtils
      .geometryFactory
      .createLineString(Array(points.head, points.last))
      .asInstanceOf[LineString]
  }.filter(!_.equals(badLine)).toList
}


val polygonizer = new Polygonizer(false)
polygonizer.add(lines.asJavaCollection)
polygonizer.add(lines.reverse.asJavaCollection)
// for (geo <- lines.map(_.asInstanceOf[Geometry])) {
  
val ans = polygonizer.getPolygons.toList.asInstanceOf[List[Polygon]]



val newP = polygonizer.getPolygons().toList.head.asInstanceOf[Polygon]

GeometryUtils.plotly(ans.head, Some(ans.last), "polygonizer split")



val ans = OrthogonalPolygonPartitioner.partition(orthPolygon)
val corners = OrthogonalPolygonPartitioner.extractCorners(orthPolygon)
val startsVertically: Boolean = corners.head.angle.abs != 90

val hc: List[Corner] = if (startsVertically) corners.tail else corners.init
val vc: List[Corner] = if (startsVertically) corners.init else corners.tail

val init: Tuple2[TreeSet[Double], List[ExtendedCorner]] = (TreeSet(), Nil)
val vEdges: List[ExtendedCorner] = OrthononalPolygonCornerExtender.extendCorners(hc, extendVertically = true)
// val vEdges: List[ExtendedCorner] = extendCorners(corners.tail, hc, true)
val vCorners: List[Corner] = vEdges.flatMap(_.toListCorner)

// val hEdges: List[ExtendedCorner] = extendCorners(corners.tail, vCorners ++ vc, false)
val hEdges: List[ExtendedCorner] = OrthononalPolygonCornerExtender.extendCorners(vc ++ vCorners, extendVertically = false)

val lines = vEdges ++ hEdges

import co.theasi.plotly._

def linePlotter(plt: CartesianPlot, line: ExtendedCorner): CartesianPlot = {
  val coords = Array(line.source, line.dest)
  plt.withScatter(coords.map(_.x), coords.map(_.y),
    ScatterOptions()
      .mode(ScatterMode.Marker, ScatterMode.Line)
      .marker(MarkerOptions().color(152, 0, 0, 0.8).lineColor(30, 0, 0))
  )
}

def diagPlotter(plt: CartesianPlot, line: Rectangle): CartesianPlot = {
  val coords = Array(line.upperLeft, line.lowerRight)
  plt.withScatter(coords.map(_.x), coords.map(_.y),
    ScatterOptions()
      .mode(ScatterMode.Marker, ScatterMode.Line)
      .marker(MarkerOptions().color(0, 152, 0, 0.8).lineColor(0, 30, 0))
  )
}

def plotly(
    polygon: Polygon,
    innerLines: List[ExtendedCorner],
    diagLines: List[Rectangle],
    plotName: String = "scatter-mode"): Unit = {
  import co.theasi.plotly._

  val xs0: Array[Double] = polygon.toArray.map(_.x)
  val ys0: Array[Double] = polygon.toArray.map(_.y)

  val p1 = Plot()
    .withScatter(xs0, ys0,
      ScatterOptions()
        .mode(ScatterMode.Marker, ScatterMode.Line)
        .name("Orthogonal Polygon"))

  val p2 = innerLines.foldLeft(p1)(linePlotter)
  val plot = diagLines.foldLeft(p2)(diagPlotter)
  draw(plot, plotName, writer.FileOptions(overwrite=true))
}

plotly(orthPolygon, lines, ans, "partitions finalized!")





import com.vividsolutions.jts.geom.{GeometryFactory, Geometry, Polygon, Coordinate, LineString}
import com.vividsolutions.jts.dissolve.LineDissolver
val geometryFactory = new GeometryFactory()

val line1 = geometryFactory.createLineString(Array(new Coordinate(0, 0), new Coordinate(1, 0)))
val line2 = geometryFactory.createLineString(Array(new Coordinate(0, 0), new Coordinate(0.75, 0)))
val line3 = geometryFactory.createLineString(Array(new Coordinate(0.25, 0), new Coordinate(1, 0)))

val dissolver = new LineDissolver()
// dissolver.add(line1)
dissolver.add(line2)
dissolver.add(line3)

val ans = dissolver.getResult()
