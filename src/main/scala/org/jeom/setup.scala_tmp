import org.jeom._

import scala.collection.immutable.TreeSet
import scala.collection.JavaConversions._
import scala.collection.JavaConverters._
import scala.collection.Searching.{search, Found, InsertionPoint, SearchResult}

import com.vividsolutions.jts.geom.{GeometryCollection, GeometryFactory, Polygon, Geometry, Coordinate, LineString}
import com.vividsolutions.jts.index.strtree.SIRtree
import com.vividsolutions.jts.operation.polygonize.Polygonizer


val ans = PolygonExtractor.extractZCTAs()

val geometryFactory = new GeometryFactory()

import GeometryUtils.IterablePolygon

val tolerance = math.pow(2, -11)
val polygon = geometryFactory.createPolygon(ans(0).multipolygon.getBoundary.getCoordinates)
val orthPolygon = OrthogonalPolygonBuilder.build(polygon, tolerance, 5, 3)
// val poly = OrthogonalPolygonBuilder.build(polygon, math.pow(2, -11), 8, 6)

val ans = OrthogonalPolygonPartitioner.partition(orthPolygon)

// val corners = OrthogonalPolygonPartitioner.extractCorners(orthPolygon)
val startsVertically: Boolean = corners.head.angle.abs != 90

val hc: List[Corner] = if (startsVertically) corners.tail else corners.init
val vc: List[Corner] = if (startsVertically) corners.init else corners.tail

val treeSet = TreeSet[Double]()
val empty: List[ExtendedCorner] = Nil

val (_, ves) = hc.sorted(CornerOrderingX).foldLeft((treeSet, empty)) {
    (tuple: Tuple2[TreeSet[Double], List[ExtendedCorner]], cn: Corner) =>

  val (tm, ecs) = tuple
  cn match {
    case Corner(Point(x, y), true, 90) if (tm.contains(y)) =>
      (tm - y, ExtendedCorner(cn.point, Point(x, (tm - y).from(y).firstKey), cn.angle) :: ecs)

    case Corner(Point(x, y), true, 90) if (!tm.contains(y)) =>
      (tm + y, ExtendedCorner(cn.point, Point(x, tm.from(y).firstKey), cn.angle) :: ecs)

    case Corner(Point(x, y), true, -90) if (tm.contains(y)) =>
      (tm - y, ExtendedCorner(cn.point, Point(x, (tm - y).to(y).lastKey), cn.angle) :: ecs)

    case Corner(Point(x, y), true, -90) if (!tm.contains(y)) =>
      (tm + y, ExtendedCorner(cn.point, Point(x, tm.to(y).lastKey), cn.angle) :: ecs)

    case Corner(Point(_, y), _, _) if (tm.contains(y)) => (tm - y, ecs)

    case Corner(Point(_, y), _, _) if (!tm.contains(y)) => (tm + y, ecs)
  }
}

val (_, ves2) = hc.sorted(CornerOrderingX).foldLeft((treeSet, empty)) {
    (tuple: Tuple2[TreeSet[Double], List[ExtendedCorner]], cn: Corner) =>

  val (tm, ecs) = tuple
  if (tm.contains(cn.y))
    cn match {
      case Corner(Point(x, y), true, 90) =>
        (tm - y, cn.extendCorner(tm - y) :: ecs)
        // (tm - y, ExtendedCorner(cn.point, Point(x, (tm - y).from(y).firstKey), cn.angle) :: ecs)

      case Corner(Point(x, y), true, -90) =>
        (tm - y, cn.extendCorner(tm - y) :: ecs)
        // (tm - y, ExtendedCorner(cn.point, Point(x, (tm - y).to(y).lastKey), cn.angle) :: ecs)

      case Corner(Point(_, y), _, _) if (tm.contains(y)) => (tm - y, ecs)
    }
  else
    cn match {
      case Corner(Point(x, y), true, 90) =>
        (tm + y, cn.extendCorner(tm - y) :: ecs)
        // (tm + y, ExtendedCorner(cn.point, Point(x, tm.from(y).firstKey), cn.angle) :: ecs)

      case Corner(Point(x, y), true, -90) =>
        (tm + y, cn.extendCorner(tm - y) :: ecs)
        // (tm + y, ExtendedCorner(cn.point, Point(x, tm.to(y).lastKey), cn.angle) :: ecs)

      case Corner(Point(_, y), _, _) => (tm + y, ecs)
    }
}


ves.toSet == vEdges.toSet
val vCorners: List[Corner] = ves.flatMap(_.toListCorner)


val (_, hes) = (vc ++ vCorners).sorted(YOrdering1).foldLeft((treeSet, empty)) {
    (tuple: Tuple2[TreeSet[Double], List[ExtendedCorner]], cn: Corner) =>

  val (tm, ecs) = tuple
  if (tm.contains(cn.x))
    cn match {
      case Corner(Point(x, y), true, 0) =>
        (tm - x, ExtendedCorner(cn, Point((tm - x).from(x).firstKey, y)) :: ecs)

      case Corner(Point(x, y), true, 180) =>
        (tm - x, ExtendedCorner(cn, Point((tm - x).to(x).lastKey, y)) :: ecs)

      case Corner(Point(x, _), _, _) => (tm - x, ecs)
    }
  else
    cn match {
      case Corner(Point(x, y), true, 0) =>
        (tm + x, ExtendedCorner(cn, Point(tm.from(x).firstKey, y)) :: ecs)

      case Corner(Point(x, y), true, 180) =>
        (tm + x, ExtendedCorner(cn, Point(tm.to(x).lastKey, y)) :: ecs)

      case Corner(Point(x, _), _, _) => (tm + x, ecs)
    }
}



val vEdges: List[ExtendedCorner] = OrthogonalPolygonPartitioner.extendCorners(corners.tail, hc, true)
val vCorners: List[Corner] = vEdges.flatMap(_.toListCorner)
val hEdges: List[ExtendedCorner] = OrthogonalPolygonPartitioner.extendCorners(corners.tail, vCorners ++ vc, false)

val t = scala.collection.immutable.TreeMap[Double, Double](1.2 -> 9.0, 2.0 -> 3.9 , -2.3 -> 4.5, 9.9 -> 17.2)

t match {
  case _: IndexedSeqLike[Double] => println("hope")
  case _ => println("damn")
}

import org.scalameter._
val tolerance = scala.math.pow(2, -11)
val time = config(
  Key.exec.benchRuns -> 100,
  Key.verbose -> true
) withWarmer {
  new Warmer.Default
} withMeasurer {
  new Measurer.IgnoringGC
} measure {
  OrthogonalPolygonBuilder.build(polygon)
}

println(s"Total time: $time")


def buildIntervalTree(corners: List[CornerPoint], isVertical: Boolean): SIRtree = {

  val tree: SIRtree = new SIRtree()
  val edges: Iterator[List[CornerPoint]] = corners.grouped(2)

  if (isVertical) 
    edges foreach { e => tree.insert(e.head.y, e.last.y, e) }
  else
    edges foreach { e => tree.insert(e.head.x, e.last.x, e) }

  tree
}

def extendCorner(corner: Corner, edgeTree: SIRtree): List[CornerPoint] = {
  tree
    .query(corner.extensionCoord)
    .toList.asInstanceOf[List[List[CornerPoint]]]
    .filter(c => corner.extensionOrder(c.head.point.y))
    .minBy(_.head.point.y)  
}

// val poly = OrthogonalPolygonBuilder.build(polygon, math.pow(2, -11), 8, 6)
// GeometryUtils.plotly(poly, Some(polygon), "fine tune improved method")


val corners = OrthogonalPolygonPartitioner.extractCorners(orthPolygon)
val startsVertically: Boolean = corners.head.angle.abs != 90

val hc: List[Corner] = if (startsVertically) corners.tail else corners.init
val vc: List[Corner] = if (startsVertically) corners.init else corners.tail
val tree = buildIntervalTree(hc, false)

val corner = corners.filter(c => c.isConvex && c.extendsVertically && c.point.x == -66.755807).head
val edge = extendCorner(corner, tree)

val line1 = geometryFactory.createLineString(
  Array(new Coordinate(edge.head.point.x, edge.head.point.y),
        new Coordinate(corner.point.x, edge.head.point.y)))
val line2 = geometryFactory.createLineString(
  Array(new Coordinate(corner.point.x, edge.head.point.y),
        new Coordinate(edge.last.point.x, edge.last.point.y)))
val line3 = geometryFactory.createLineString(
  Array(new Coordinate(corner.point.x, corner.point.y),
        new Coordinate(corner.point.x, edge.head.point.y)))

val badLine = geometryFactory.createLineString(
  Array(new Coordinate(edge.head.point.x, edge.head.point.y),
        new Coordinate(edge.last.point.x, edge.last.point.y)))


val lines = line1 :: line2 :: line3 :: { 
  orthPolygon.sliding(2, 1).map { points =>
    GeometryUtils
      .geometryFactory
      .createLineString(Array(points.head, points.last))
      .asInstanceOf[LineString]
  }.filter(!_.equals(badLine)).toList
}


val polygonizer = new Polygonizer(false)
polygonizer.add(lines.asJavaCollection)
polygonizer.add(lines.reverse.asJavaCollection)
// for (geo <- lines.map(_.asInstanceOf[Geometry])) {
  
val ans = polygonizer.getPolygons.toList.asInstanceOf[List[Polygon]]



val newP = polygonizer.getPolygons().toList.head.asInstanceOf[Polygon]

GeometryUtils.plotly(ans.head, Some(ans.last), "polygonizer split")



val ans = OrthogonalPolygonPartitioner.partition(orthPolygon)

val startsVertically: Boolean = corners.head.angle.abs != 90

val hc: List[Corner] = if (startsVertically) corners.tail else corners.init
val vc: List[Corner] = if (startsVertically) corners.init else corners.tail

val init: Tuple2[TreeSet[Double], List[ExtendedCorner]] = (TreeSet(), Nil)
val vEdges: List[ExtendedCorner] = hc
  .sorted(CornerOrderingX)
  .foldLeft(init)(OrthogonalPolygonPartitioner.sweepFolder(false))
  ._2

// val vEdges: List[ExtendedCorner] = extendCorners(corners.tail, hc, true)
val vCorners: List[Corner] = vEdges.flatMap(_.toListCorner)

// val hEdges: List[ExtendedCorner] = extendCorners(corners.tail, vCorners ++ vc, false)
val hEdges: List[ExtendedCorner] = (vc ++ vCorners)
  .sorted(CornerOrderingY)
  .foldLeft(init)(OrthogonalPolygonPartitioner.sweepFolder(true))
  ._2

val lines = vEdges ++ hEdges

import co.theasi.plotly._

def linePlotter(plt: CartesianPlot, line: ExtendedCorner): CartesianPlot = {
  val coords = Array(line.source, line.dest)
  plt.withScatter(coords.map(_.x), coords.map(_.y),
    ScatterOptions()
      .mode(ScatterMode.Marker, ScatterMode.Line)
      .marker(MarkerOptions().color(152, 0, 0, 0.8).lineColor(30, 0, 0))
  )
}

def diagPlotter(plt: CartesianPlot, line: Rectangle): CartesianPlot = {
  val coords = Array(line.upperLeft, line.lowerRight)
  plt.withScatter(coords.map(_.x), coords.map(_.y),
    ScatterOptions()
      .mode(ScatterMode.Marker, ScatterMode.Line)
      .marker(MarkerOptions().color(0, 152, 0, 0.8).lineColor(0, 30, 0))
  )
}

def plotly(
    polygon: Polygon,
    innerLines: List[ExtendedCorner],
    diagLines: List[Rectangle],
    plotName: String = "scatter-mode"): Unit = {
  import co.theasi.plotly._

  val xs0: Array[Double] = polygon.toArray.map(_.x)
  val ys0: Array[Double] = polygon.toArray.map(_.y)

  val p1 = Plot()
    .withScatter(xs0, ys0,
      ScatterOptions()
        .mode(ScatterMode.Marker, ScatterMode.Line)
        .name("Orthogonal Polygon"))

  val p2 = innerLines.foldLeft(p1)(linePlotter)
  val plot = diagLines.foldLeft(p2)(diagPlotter)
  draw(plot, plotName, writer.FileOptions(overwrite=true))
}

plotly(orthPolygon, lines, ans, "partitions finalized!")
